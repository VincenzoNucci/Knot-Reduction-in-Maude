fmod GAUSS-CODE is

   protecting INT .
   protecting BOOL .
   sorts NeGauss Gauss .

   subsorts Int < NeGauss < Gauss .

   op ~ : -> Gauss [ctor] .

   op _;_ : Int Int -> NeGauss [assoc id: ~ ctor] .
   op _;_ : Int Gauss -> NeGauss [ditto] .
   op _;_ : Gauss Int -> NeGauss [ditto] .
   op _;_ : Gauss Gauss -> Gauss [ditto] .

   op _;_ : Int NeGauss -> NeGauss [ditto] .
   op _;_ : NeGauss Int -> NeGauss [ditto] .
   op _;_ : NeGauss NeGauss -> NeGauss [ditto] .

   op _;_ : NeGauss Gauss -> NeGauss [ditto] .
   op _;_ : Gauss NeGauss -> NeGauss [ditto] .


   op remove_from_ : Int NeGauss -> Gauss .
   op length : Gauss -> Int .
   op positionOf_in_ : Int Gauss -> Int .
   op add_in_to_ : Gauss Int Gauss -> NeGauss .
   op move_to_in_ : Int Int NeGauss -> NeGauss .
   op next : Gauss -> Gauss .
   op nextPositive : Gauss -> Gauss .
   op nextNegative : Gauss -> Gauss .
   op maxCross : Gauss -> Int .
   op _adj_in_ : Int Int Gauss -> Bool .

   vars G G' G'' : Gauss .
   var NeG : NeGauss .
   vars I K : Int .

   --- REMOVE OPERATION
   eq remove I from NeG ; I = NeG .
   eq remove I from I ; NeG = NeG .
   eq remove I from G ; (I ; G') = G ; G' .

   --- LENGTH OPERATION
   eq length(~) = 0 .
   eq length(I) = 1 .
   eq length(I ; G) = 1 + length(G) .

   --- POSITION OPERATION
   --- I is found
   eq positionOf I in I = 0 .
   eq positionOf I in I ; G = 0 .
   eq positionOf I in G ; I = length(G) .
   eq positionOf I in G ; (I ; G') = length(G) .
   --- I is not found
   eq positionOf I in ~ = -1 .
   ceq positionOf I in K = -1 if I =/= K .
   ceq positionOf I in K ; G = -1 if I =/= K .
   ceq positionOf I in G ; K = -1 if I =/= K .
   ceq positionOf I in G ; (K ; G') = -1 if I =/= K .

   --- ADD OPERATOR
   eq add I in K to ~ = I .
   ceq add I in K to G = G ; I if K = length(G) .
   eq add I in 0 to G = I ; G .
   ceq add I in K to G ; G' = G ; (I ; G') if K = length(G) .

   ceq add G in K to G' ; G'' = G' ; (G ; G'') if K = length(G') . 

   --- MOVE OPERATION
   eq move I to K in NeG = ( add I in K to ( remove I from NeG ) ) .

   --- MAXCROSS OPERATION
   eq maxCross(I) = I .
   eq maxCross(G ; I) = if I > maxCross(G) then I else maxCross(G) fi .
   eq maxCross(G ; G') = if maxCross(G) > maxCross(G') then maxCross(G) else maxCross(G') fi .

   --- NEXT OPERATION
   eq next(G) = ((maxCross(G) + 1) ; - (maxCross(G) + 1)) .
   eq nextPositive(G) = maxCross(G) + 1 .
   eq nextNegative(G) = - (maxCross(G) + 1) .

---ADJACENT OPERATION
   eq I adj K in (G ; I ; K ; G') = true .
   eq I adj K in (G ; K ; I ; G') = true .
   eq I adj K in (I ; G ; G' ; K) = true .
   eq I adj K in (K ; G ; G' ; I) = true .
   eq I adj K in NeG = false [owise] .  

endfm

mod R-MOVES is
   
   protecting GAUSS-CODE .
   protecting BOOL .

   

   op canApplyMove1_for_ : Gauss Int -> Bool .
   op canApplyMove2_for_and_ : Gauss Int Int -> Bool .
   op canApplyMove3 : Gauss -> Bool .

   op canApplyMove1 : Gauss -> Bool .

   op sign : Int -> Int .

   vars G G' G'' G''' : Gauss .
   var NeG : NeGauss .
   vars I K J Z : Int .



   ceq sign(I) = 1 if I > 0 .
   ceq sign(I) = -1 if I < 0 .
   
   --- conditions to verify if the application of a reidemeister move is possible
   ceq canApplyMove1 (G) for I = true if I adj - I in G = true .
   eq canApplyMove1(G) for I = false [owise] .

   ceq canApplyMove2(G) for I and K = true if I adj K in G /\ - I adj - K in G = true .
   eq canApplyMove2(G) for I and K = false [owise] .

   eq canApplyMove3(G ; I ; K ; G' ; - I ; - J ; - K ; J ; G'') = true .
   eq canApplyMove3(G ; I ; K ; G' ; - J ; - I ; - K ; J ; G'') = true .
   eq canApplyMove3(G ; I ; J ; G' ; K ; Z ; G'') = false [owise] .   


   eq canApplyMove1(~) = false .
   eq canApplyMove1(I) = false .
   eq canApplyMove1(I ; G) = canApplyMove1 G for I or canApplyMove1(G) .

   --- application of move 1 (remove loop)
   rl [move1] : (G ; I ; - I ) => (G) .
   rl [move1] : (I ; - I ; G) => (G) .
   rl [move1] : (I ; G ; - I) => (G) .

   --- application of inverse of move 1 (add loop)
   crl [move1Inv] : (G ; G') => (G ; next(G ; G') ; G') if length(G ; G') > 0 .
   
   --- application of move 2
   crl [move2] : (I ; K ; G' ; - I ; - K) => (G') if canApplyMove2(I ; K ; G' ; - I ; - K) for I and K = true .
   crl [move2] : (G ; I ; K ; G' ; - K ; - I ; G'') => (G ; G' ; G'') if canApplyMove2(I ; K ; G' ; - K ; - I) for I and K = true .
   
   --- application of inverse of move 2 
   crl [move2Inv] : (G ; G') => (G ; nextPositive(G ; G') ; nextPositive(next(G ; G')) ; nextNegative(next(G ; G')) ; nextNegative(G ; G') ; G') if length(G ; G') > 0 .
   crl [move2Inv] : (G ; G') => (nextPositive(G ; G') ; nextPositive(next(G ; G')) ; G ; nextNegative(next(G ; G')) ; nextNegative(G ; G') ; G') if length(G ; G') > 0 .
   crl [move2Inv] : (G ; G') => (nextPositive(G ; G') ; nextPositive(next(G ; G')) ; nextNegative(next(G ; G')) ; nextNegative(G ; G') ; G ; G') if length(G ; G') > 0 .
   crl [move2Inv] : (G ; G') => (G ; nextPositive(G ; G') ; nextPositive(next(G ; G')) ; G' ; nextNegative(next(G ; G')) ; nextNegative(G ; G')) if length(G ; G') > 0 .
   
   --- application of move 3
   crl [move3] : (G ; I ; K ; G' ; - I ; - J ; - K ; J ; G'') => (G ; K ; J ; G' ; - I ; - J ; I ; - K ; G'' ) if canApplyMove3(G ; I ; K ; G' ; - I ; - J ; - K ; J ; G'') = true .
   crl [move3] : (G ; I ; K ; G' ; - J ; - I ; - K ; J ; G'') => (G ; K ; J ; G' ; - J ; - I ; I ; - K ; G'' ) if canApplyMove3(G ; I ; K ; G' ; - I ; - J ; - K ; J ; G'') = true .
   
   --- rule to pass from the gauss code to the unknot
   crl [unknot] : G => ~ if length(G) = 0 .
   
   --- necessary but not sufficient condition for having a minimum knot
   --- crl [minknot] : G => G if canApplyMove1(G) = false /\ canApplyMove2(G) = false /\ length(G) > 0 .

endm


