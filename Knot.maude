fmod GAUSS-CODE is

   protecting INT .
   sorts NeGauss Gauss .

   subsorts Int < NeGauss < Gauss .

   op ~ : -> Gauss [ctor] .

   op _;_ : Int Int -> NeGauss [assoc id: ~ ctor] .
   op _;_ : Int Gauss -> NeGauss [ditto] .
   op _;_ : Gauss Int -> NeGauss [ditto] .
   op _;_ : Gauss Gauss -> Gauss [ditto] .

   op _;_ : Int NeGauss -> NeGauss [ditto] .
   op _;_ : NeGauss Int -> NeGauss [ditto] .
   op _;_ : NeGauss NeGauss -> NeGauss [ditto] .

   op _;_ : NeGauss Gauss -> NeGauss [ditto] .
   op _;_ : Gauss NeGauss -> NeGauss [ditto] .


   op remove_from_ : Int NeGauss -> Gauss .
   op length : Gauss -> Int .
   op positionOf_in_ : Int Gauss -> Int .
   op add_in_to_ : Int Int Gauss -> NeGauss .
   op move_to_in_ : Int Int NeGauss -> NeGauss .

   vars G G' : Gauss .
   var NeG : NeGauss .
   vars I K : Int .

   --- REMOVE OPERATION
   eq remove I from NeG ; I = NeG .
   eq remove I from I ; NeG = NeG .
   eq remove I from G ; (I ; G') = G ; G' .

   --- LENGTH OPERATION
   eq length(~) = 0 .
   eq length(I) = 1 .
   eq length(I ; G) = 1 + length(G) .

   --- POSITION OPERATION
   --- I is found
   eq positionOf I in I = 0 .
   eq positionOf I in I ; G = 0 .
   eq positionOf I in G ; I = length(G) .
   eq positionOf I in G ; (I ; G') = length(G) .
   --- I is not found
   eq positionOf I in ~ = -1 .
   ceq positionOf I in K = -1 if I =/= K .
   ceq positionOf I in K ; G = -1 if I =/= K .
   ceq positionOf I in G ; K = -1 if I =/= K .
   ceq positionOf I in G ; (K ; G') = -1 if I =/= K .

   --- ADD OPERATOR
   eq add I in K to ~ = I .
   ceq add I in K to G = G ; I if K = length(G) .
   eq add I in 0 to G = I ; G .
   ceq add I in K to G ; G' = G ; (I ; G') if K = length(G) .

   --- MOVE OPERATION
   eq move I to K in NeG = ( add I in K to ( remove I from NeG ) ) .

endfm


--- Work In Progress

fmod KNOT-DEFINITION is

   protecting GAUSS-CODE .

   sort Knot .
   sort NegInt .

   subsort NegInt < Int .

   vars I K : Int .
   var Z : NegInt .
   var NeG : NeGauss .
   var G G' : Gauss .

   op unknot : -> Knot .
   op red : Knot -> Knot .


   op _negIn_ : Int NeGauss -> Bool .
   op _adj_in_ : Int Int NeGauss -> Bool .
   op s(_,_,_) : Int Int NeGauss -> Int . ---successor means it's after the int im checking
   op p(_,_,_) : Int Int NeGauss -> Int . ---predecessor means it's before the int im checking

   eq - I + I = 0 .

   ---ceq s(I,K,NeG) = true if I adj K in NeG = true .
   ---eq s(I,K,NeG) = -1 [owise] .

   ---ceq p(I,K,NeG) = true if I adj K in NeG = true .
   ---eq p(I,K,NeG) = -1 [owise] .
    
   ---ADJACENT OPERATION
   eq I adj K in (G ; I ; K ; G') = true .
   eq I adj K in (G ; K ; I ; G') = true .
   eq I adj K in (I ; G ; G' ; K) = true .
   eq I adj K in (K ; G ; G' ; I) = true .
   eq I adj K in NeG = false [owise] .  

   ---ceq I negIn NeG = true if I adj K in NeG = true /\ - I + I = 0 . 
endfm

mod R-MOVES is

   protecting KNOT-DEFINITION .

   vars G G' G'' : Gauss .
   var NeG : NeGauss .
   vars I K J Z : Int .

   crl [move1] : (G ; I ; K ; G') => (G ; G') if I + K = 0 .
   crl [move2] : (G ; I ; K ; G' ; J ; Z) => (G ; G') if I + J = 0 /\ K + Z = 0 .
   crl [move3] : (G ; I ; J ; G' ; K ; Z ; G'') => (G ; J ; I ; G' ; Z ; K ; G'') if J + K = 0 .

endm


